---
timestamp: 'Sun Nov 02 2025 18:41:13 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251102_184113.4617b4e3.md]]'
content_id: a7e915cf3212f1773340b0e04d19c00ca759b724b046df5c62bbcf39f2b2c4a5
---

# Common Pitfalls

Synchronizations are in some ways a reflection of the underlying cause-and-effect structure of your application. Here are a few common issues that can occur while programming with synchronizations, especially when you might miss a few edge cases.

## Zero Matches

Usually occurring with a `where` clause in which you are looking for an array or multiple matches, there's the possibility that your queries return no frames at all. What happens then? Since the then occurs for each frame, this means **the synchronization does not fire at all**. In the sample app, ConceptBox, there was initially a synchronization for returning all files that looked like this:

```typescript
export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // frames = [] if no files uploaded yet!
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

However, this would always timeout and not respond if there were no files uploaded yet. Instead, a general pattern to fix this is to be explicit about your default return value, as follows:

```typescript
import { actions, Frames, Sync } from "@engine";
import { Requesting, Sessioning, FileUploading, Sharing } from "@concepts";

export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    // Make sure to grab the original frame to return to the response
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // Explicitly check if frames are empty
    if (frames.length === 0) {
      // Then join the original frame with whatever result variables you need
      const response = {...originalFrame, [results]: []}
      // Note the additional import `Frames` available from @engine 
      return new Frames(response)
    }
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

There are only two minor additions:

1. Grabbing the original frame, as the `then` clause needs other bindings.
2. Checking for whatever empty condition you may have, then adding any binding you may need for results.

## Missing actionId in `then` clause

This is an error you may occasionally encounter with malformed synchronizations, particularly in the `where` clause. It occurs primarily for two reasons:

1. Your `where` function is not properly returning a set of Frames. Make sure that the function is labeled as `async`, and that you await each call to `.query`.
2. Your frame is missing other bindings, meaning you manually created a new frame or didn't join with an original frame. See the previous example for a nice pattern to do this when you want to form an entirely new frame.

You are working within a codebase that uses the **Requesting** concept to handle HTTP requests and synchronizations.

**Goal:**\
Create a new file called `src/syncs/CSVImport.sync.ts` that defines synchronizations for two backend-only routes:

* `/CSVImport/parseCSVFile`

* `/CSVImport/parseCSVLine`

These two routes should **not** be directly executed as passthrough routes and should **not** be handled by any concept actions.\
They are backend-only maintenance actions that should only ever be run manually by the backend at the start of a new semester.

**Important instructions (read carefully):**

1. **Do NOT modify or edit any files inside `src/concepts/Requesting/`.**\
   This includes `passthrough.ts`, `mod.ts`, or any other part of the Requesting concept.\
   You should not add these routes to `exclusions` or `inclusions`.

2. **Instead, create a new sync file** named `CSVImport.sync.ts` in the `src/syncs` directory.

3. In this sync file:

   * Use `when(Requesting.request, matches({ path: ... }))` to detect incoming requests for `/CSVImport/parseCSVFile` and `/CSVImport/parseCSVLine`.

   * When these requests are received, respond using `Requesting.respond` with an error message such as:

     > "Route disabled: backend-only maintenance route."

   * This ensures these routes no longer log “UNVERIFIED ROUTE” warnings but also do not perform any real actions.

4. Leave all other passthrough and concept behavior unchanged.

***

### Example output (what you should generate)

```typescript
/**
 * src/syncs/CSVImport.sync.ts
 *
 * Synchronizations for backend-only CSV import routes.
 * These routes are intentionally disabled for client or public access.
 * They should only ever be used by the backend at the start of a new semester.
 */

import { sync, when, actions, matches } from "syncing";
import { Requesting } from "../concepts/Requesting/mod.ts";

export default [
  sync("CSVImport_DisabledRoutes", [
    when(
      Requesting.request,
      matches({ path: "/CSVImport/parseCSVFile" }),
      ({ request }) =>
        actions([
          Requesting.respond,
          { request, error: "Route disabled: backend-only maintenance route." },
        ]),
    ),

    when(
      Requesting.request,
      matches({ path: "/CSVImport/parseCSVLine" }),
      ({ request }) =>
        actions([
          Requesting.respond,
          { request, error: "Route disabled: backend-only maintenance route." },
        ]),
    ),
  ]),
];
```

***

**Summary:**\
Gemini should output only the new file `src/syncs/CSVImport.sync.ts`.\
It must not touch or reference `passthrough.ts` or make any modifications to the Requesting concept.

\[@Example]\((../../src/syncs/sample.sync.ts)
