---
timestamp: 'Sun Nov 02 2025 18:25:16 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251102_182516.904cb833.md]]'
content_id: 91ede11fb352563acad0875445fbdc83c9d66665bd4213d9ad36b8481ecbc278
---

# Common Pitfalls

Synchronizations are in some ways a reflection of the underlying cause-and-effect structure of your application. Here are a few common issues that can occur while programming with synchronizations, especially when you might miss a few edge cases.

## Zero Matches

Usually occurring with a `where` clause in which you are looking for an array or multiple matches, there's the possibility that your queries return no frames at all. What happens then? Since the then occurs for each frame, this means **the synchronization does not fire at all**. In the sample app, ConceptBox, there was initially a synchronization for returning all files that looked like this:

```typescript
export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // frames = [] if no files uploaded yet!
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

However, this would always timeout and not respond if there were no files uploaded yet. Instead, a general pattern to fix this is to be explicit about your default return value, as follows:

```typescript
import { actions, Frames, Sync } from "@engine";
import { Requesting, Sessioning, FileUploading, Sharing } from "@concepts";

export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    // Make sure to grab the original frame to return to the response
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // Explicitly check if frames are empty
    if (frames.length === 0) {
      // Then join the original frame with whatever result variables you need
      const response = {...originalFrame, [results]: []}
      // Note the additional import `Frames` available from @engine 
      return new Frames(response)
    }
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

There are only two minor additions:

1. Grabbing the original frame, as the `then` clause needs other bindings.
2. Checking for whatever empty condition you may have, then adding any binding you may need for results.

## Missing actionId in `then` clause

This is an error you may occasionally encounter with malformed synchronizations, particularly in the `where` clause. It occurs primarily for two reasons:

1. Your `where` function is not properly returning a set of Frames. Make sure that the function is labeled as `async`, and that you await each call to `.query`.
2. Your frame is missing other bindings, meaning you manually created a new frame or didn't join with an original frame. See the previous example for a nice pattern to do this when you want to form an entirely new frame.

Using the document “Implementing Synchronizations” as guidance, update the configuration for the Requesting action server so that the following actions are explicitly **excluded** and not handled by any synchronizations:

* `/api/CSVImport/parseCSVFile`

* `/api/CSVImport/parseCSVLine`

These two routes should **not** trigger any concept actions directly, and **no syncs** should be written for them. They are backend-only maintenance actions that should only ever be executed by the backend at the start of a new semester.

Your output should:

1. Mark both actions as **excluded** so they no longer generate the “UNVERIFIED ROUTE” warnings.

2. Ensure that if a request to either route is made, it simply becomes a `Requesting.request` action that times out (since no syncs exist for it).

3. Leave all other routes and included actions unchanged.

Make sure the exclusion is done in the same format and style as other concept or Requesting configuration files in this system.

**Do not modify any files inside `src/concepts/Requesting/`.**\
Instead, **create a new sync file at `src/syncs/CSVImport.sync.ts`** that defines synchronizations responding to the paths:

* `/CSVImport/parseCSVFile`

* `/CSVImport/parseCSVLine`

The sync should catch these `Requesting.request` actions and either respond with an error message or let them time out. No passthrough configuration or modification to `passthrough.ts` should be made.
