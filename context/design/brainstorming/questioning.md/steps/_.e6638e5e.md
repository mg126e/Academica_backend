---
timestamp: 'Mon Nov 03 2025 20:51:11 GMT-0500 (Eastern Standard Time)'
parent: '[[..\20251103_205111.685d14e5.md]]'
content_id: e6638e5ec7f309eb7c276e236bbc22e6c2d18283472cd3669235a3885750256f
---

# Common Pitfalls

Synchronizations are in some ways a reflection of the underlying cause-and-effect structure of your application. Here are a few common issues that can occur while programming with synchronizations, especially when you might miss a few edge cases.

## Zero Matches

Usually occurring with a `where` clause in which you are looking for an array or multiple matches, there's the possibility that your queries return no frames at all. What happens then? Since the then occurs for each frame, this means **the synchronization does not fire at all**. In the sample app, ConceptBox, there was initially a synchronization for returning all files that looked like this:

```typescript
export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // frames = [] if no files uploaded yet!
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

However, this would always timeout and not respond if there were no files uploaded yet. Instead, a general pattern to fix this is to be explicit about your default return value, as follows:

```typescript
import { actions, Frames, Sync } from "@engine";
import { Requesting, Sessioning, FileUploading, Sharing } from "@concepts";

export const ListMyFilesRequest: Sync = ({ request, session, user, file, filename, results }) => ({
  when: actions([Requesting.request, { path: "/my-files", session }, { request }]),
  where: async (frames) => {
    // Make sure to grab the original frame to return to the response
    const originalFrame = frames[0];
    frames = await frames.query(Sessioning._getUser, { session }, { user });
    frames = await frames.query(FileUploading._getFilesByOwner, { owner: user }, { file, filename });
    // Explicitly check if frames are empty
    if (frames.length === 0) {
      // Then join the original frame with whatever result variables you need
      const response = {...originalFrame, [results]: []}
      // Note the additional import `Frames` available from @engine 
      return new Frames(response)
    }
    return frames.collectAs([file, filename], results);
  },
  then: actions([Requesting.respond, { request, results }]),
});
```

There are only two minor additions:

1. Grabbing the original frame, as the `then` clause needs other bindings.
2. Checking for whatever empty condition you may have, then adding any binding you may need for results.

## Missing actionId in `then` clause

This is an error you may occasionally encounter with malformed synchronizations, particularly in the `where` clause. It occurs primarily for two reasons:

1. Your `where` function is not properly returning a set of Frames. Make sure that the function is labeled as `async`, and that you await each call to `.query`.
2. Your frame is missing other bindings, meaning you manually created a new frame or didn't join with an original frame. See the previous example for a nice pattern to do this when you want to form an entirely new frame.

Create a new file named `src/syncs/CourseScheduling.sync.ts` that defines synchronizations for the following verified routes:

* /CourseScheduling/deleteSchedule
* /CourseScheduling/addSection
* /CourseScheduling/removeSection
* /CourseScheduling/duplicateSchedule

These routes must only execute if:

1. The user making the request has a valid session (authenticated).
2. The sessionâ€™s user is the owner of the schedule being modified or deleted.

If either condition fails, the synchronization should respond with an appropriate error:

* message: "Unauthorized: user not permitted to modify this schedule."
* code: 403

Implementation requirements:

Do NOT modify or extend the Requesting concept.

Assume that each request includes a valid session context in the request.session object containing userId.

Assume that schedules in the internal database include an ownerId field for comparison.

Structure:

For each route, create a Sync that:

when: listens for \[Requesting.request, { path: "/CourseScheduling/<route>" }, { request }]

where: validates the session and ownership before proceeding.

then: either allows the operation to continue or responds with the forbidden error.

This file should only handle verification; it should not implement the actual add/remove/delete logic itself.

Do not make assumptions about the backend database schema beyond schedule.ownerId and request.session.userId.

Do not use placeholder imports or npm modules.

Output the full code for CourseScheduling.sync.ts.

Reference CourseSchedulingConcept for the action specifics and do not assume object structures.

\[@Example]\((../../src/syncs/sample.sync.ts)
